### 一、技术
- [ ] 1. 算法 / Coding
- 数量：Easy (20左右) + Medium (5左右)；
- 范围：数组、字符串、Map/Set、双指针、简单二叉树；
- 要求：20-30分钟独立写出 + 讲解思路和复杂度。

- [x] 1) 数组题
- [x] 题 1：最小差值对（数组 + 排序）
  给定一个整数数组 nums，请返回任意两个不同元素之间的最小绝对差值。

  - 输入：nums: number[]，长度 ≥ 2
  - 输出：number
  - 示例：[3, 8, 2] → 最小差值是 |3-2| = 1，返回 1。
  - 要求：时间复杂度尽量小于 O(n²)。

- [x] 题 2：连续子数组的最大和（Array + DP 经典）
  给定一个整数数组 nums，找到一个非空连续子数组，使得这个子数组的和最大，并返回这个和。

  - 输入：nums: number[]
  - 输出：number
  - 示例：[-2,1,-3,4,-1,2,1,-5,4] → 最大和子数组是 [4,-1,2,1]，和为 6。

- [x] 2) 字符串题
- [x] 题 3：压缩字符串（String）
  给定一个只包含小写字母的字符串 s，把连续相同字符压缩成“字符 + 次数”，次数为 1 时可以省略。

  - 输入："aaabbc"
  - 输出："a3b2c"
  - 输入："abcd" → "abcd"。
  - 要求：返回新字符串，不原地修改；尽量一次遍历完成。

- [x] 题 4：判断能否通过删除一个字符变成回文（String + 双指针思维）
  给定一个字符串 s，你可以最多删除一个字符。判断剩下的字符串能否是回文。

  - 输入："abca" → 可以删掉 b 或 c，返回 true；
  - 输入："abc" → 不管删谁都不是回文，返回 false。

- [x] 3) Map/Set 题x
- [x] 题 5：第一个不重复的字符（Hash / Map）
  给定字符串 s，找到第一个在字符串中只出现一次的字符，返回它的下标；如果不存在，返回 -1。

  - 输入："leetcode" → 返回 0（字符 l）x
  - 输入："aabb" → 返回 -1。

- [x] 题 6：数组去重并保持原顺序（Set + 辅助x结构）
  实现函数 unique(nums: number[]): number[]，返回一个新数组，去掉重复元素，保留第一次出现的顺序。

  - 输入：[2, 3, 2, 2, 1] → 输出 [2, 3, 1].

- [x] 4) 双指针题
- [x] 题 7：有序数组的两数之和（Two Pointers）
  给定一个升序排列的整数数组 nums 和一个目标值 target，找出和为 target 的两个数的下标（假设一定存在且唯一）。

  - 输入：nums = [1,2,4,6,10], target = 8 → 输出 [1,3]（2 + 6）。
  - 要求：
     时间复杂度 O(n)；
     不使用额外数组复制。

- [x] 5) 简单二叉树题x
- [x] 题 8：二叉树的最大深度

  定义二叉树节点：x

  ```python
  interface TreeNode {
    val: number;
    left: TreeNode | null;
    right: TreeNode | null;
  }
  ```
  实现函数 maxDepth(root: TreeNode | null): number，返回树的最大深度（根节点深度为 1）。

  - 示例：只有一个根节点 → 返回 1
  - 示例：根 → 左 → 左，共三层 → 返回 3。

---

- [ ] 2. 前端 Live Coding 题
准备三个可以从0写出的小题：
- debounce / throttle 函数 + 搜索框组件（React）；
- 简单分页列表（上一页/下一页 + 当前页高亮）；
- 带校验的表单（必填、错误提示、提交 loading）。
目标：自己计时；30-40分钟跑起来。

---

- [ ] 3. 小型系统设计
五步：
- [ ] 1) 需求梳理

有哪些角色（用户、管理员…）
用户能做什么（增删改查、搜索、分类、分享…）
哪些是「必须现在支持」的，哪些可以以后再做。

- [ ] 2) 核心实体 & 关系

例如 Library 系统：User / Library / Bookshelf / Book / Tag
画出 “谁拥有谁、谁引用谁”，就像你现在的 Library/Bookshelf/Book 一样。

- [ ] 3) 数据模型

每个实体有哪些字段（id、name、created_at…）
简单想想存在关系型（表）还是文档型都可以，重点是字段关系。

- [ ] 4) API / 前后端交互

罗列核心接口：
GET /libraries、POST /libraries、PATCH /libraries/:id…
前端页面如何调用：
列表页、详情页、编辑弹窗，各自用哪些接口。

- [ ] 5)  状态管理 & 非功能需求

前端：在哪里缓存数据、如何做乐观更新、如何回退；
非功能：权限（谁能改）、审计（谁改过）、错误处理与回退、日志/监控。

- [ ] 6)  例子
你可以现在就做一个“小型系统设计文档”，把你实际做的 Library Overview 按上面 5 步写一遍：

需求：Overview 要展示哪些数据，支持哪些操作；
实体：Library / Bookshelf / Book / Tag 关系；
数据模型：你现在后端的字段结构；
API：你已经在用的那几个 endpoints；
前端状态 & 质量：React Query、缓存、回归、E2E。
这其实就是一个小系统设计，只是你已经实现完了。
再选一个你没做过的简单场景（比如书签系统），照着同样套路设计一次，就是练习。

### 二、项目
- 面试官导向的“项目说明”
- [ ] 1. 一份对面试官友好的「项目说明」（1–2 页）

- [ ] 1) 背景：这个模块原来有什么痛点。
你具体做了什么：
ck + ids + regression；
ISS + ADR + SPEC；
Playwright E2E。

- [ ] 2) 结果：
解决了哪些具体问题（tags、desc、cover 等）；
现在如何回归；
如何推广到 bookshelf / 其它模块。

- [ ] 2. 3～5 个「可深挖点」的讲稿
每个点准备“问题 → 分析 → 方案 → 取舍”的简短故事：

Tags 缓存 bug 的根因与最终方案；
为什么要引入 SPEC / ADR，不直接改代码；
为什么自动化只覆盖关键路径，不做 100% 全覆盖。

- [ ] 3. 英文版本的项目介绍
用英文写 / 说一遍：
你负责的模块；
遇到的问题；
你设计的质量闭环；
结果和影响。
目标：2–3 分钟能完整讲清楚。

### 三、英文沟通
- [ ] 1. 常见行为题答案草稿（英文为主）
至少准备 5 个场景：

你如何发现 Library 问题并推动修复；
与 PM / Designer 对齐需求的经历；
和其他开发在实现方案上有分歧怎么处理；
遇到 deadline 很紧时怎么取舍质量 vs. 速度；
失败/踩坑的经历，以及学到了什么。

- [ ] 2. 自我介绍 + 职业目标（英文）
1 分钟版：背景 + 核心技能 + 当前关注点；
3 分钟版：补充代表项目（Library）+ 想去什么样的团队、能提供什么。

- [ ] 3. 至少做 1～2 次模拟面试（自己或找人）
自己录屏/录音：
自我介绍；
Library 项目故事；
回答 2–3 个行为题。
复盘：语速、逻辑、卡壳点。