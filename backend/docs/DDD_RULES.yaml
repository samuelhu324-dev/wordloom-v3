# ============================================
# Wordloom v3 DDD 规则追踪系统
# ============================================
# 基于老架构分析和新业务需求
# 最后更新：2025-11-11

metadata:
  version: "3.0"
  domain_model: "Library → Bookshelf → Book → Block"
  architecture_style: "Hexagonal + Domain-Driven Design"
  aggregate_model: "Independent Aggregate Roots (不嵌套)"
  created_at: "2025-11-10"
  last_updated: "2025-11-12"

  # Phase 1 Implementation Status
  phase_1_status: "COMPLETED + ARCHITECTURE DECISION"
  phase_1_completion_date: "2025-11-11"
  architecture_refactor_date: "2025-11-12"
  modules_generated: 6  # Library, Bookshelf, Book, Block, Tag, Media
  files_generated: 56   # 6 modules × 8 files + shared/base.py + infra/storage.py + DDD_RULES.yaml

  # Library 模块完成状态
  library_module_status: "IMPLEMENTED"
  library_completion_date: "2025-11-12"
  library_rules_coverage: "RULE-001 ✅ | RULE-002 ✅ | RULE-003 ✅"
  library_adr_reference: "ADR-008-library-service-repository-design.md"
  library_files_count: 8  # domain.py, service.py, repository.py, models.py, exceptions.py, schemas.py, router.py, conftest.py

  # Bookshelf 模块完成状态
  bookshelf_module_status: "IMPLEMENTED"
  bookshelf_completion_date: "2025-11-12"
  bookshelf_rules_coverage: "RULE-004 ✅ | RULE-005 ✅ | RULE-006 ✅ | RULE-010 ✅"
  bookshelf_adr_reference: "ADR-009-bookshelf-service-repository-design.md"
  bookshelf_files_count: 8  # domain.py, service.py, repository.py, models.py, exceptions.py, schemas.py, router.py, conftest.py

  # Book 模块完成状态
  book_module_status: "IMPLEMENTED"
  book_completion_date: "2025-11-12"
  book_rules_coverage: "RULE-009 ✅ | RULE-011 ✅ | RULE-012 ✅ | RULE-013 ✅"
  book_adr_reference: "ADR-010-book-service-repository-design.md"
  book_files_count: 8  # domain.py, service.py, repository.py, models.py, exceptions.py, schemas.py, router.py, conftest.py
  legacy_system: "WordloomBackend/orbit"

  # Block 模块完成状态
  block_module_status: "IMPLEMENTED"
  block_completion_date: "2025-11-12"
  block_rules_coverage: "RULE-013-REVISED ✅ | RULE-014 ✅ | RULE-015-REVISED ✅ | RULE-016 ✅"
  block_adr_reference: "ADR-011-block-service-repository-design.md"
  block_files_count: 8  # domain.py, service.py, repository.py, models.py, exceptions.py, schemas.py, router.py, conftest.py
  block_design_improvements: "Fractional Index Ordering + HEADING as BlockType"
  shared_base_path: "backend/shared/base.py"
  infra_storage_path: "backend/infra/storage.py"

# ============================================
# Domain 1: Library（图书馆 - 聚合根）
# ============================================

domains:
  library:
    name: "Library（图书馆）"
    type: "AggregateRoot"
    description: "用户的唯一数据容器，所有书架、书籍、块的顶层容器。代表用户的完整知识库。"
    status: "implemented"

    implementation_files:
      - "backend/domains/library/domain.py"
      - "backend/domains/library/models.py"
      - "backend/domains/library/schemas.py"
      - "backend/domains/library/repository.py"
      - "backend/domains/library/service.py"
      - "backend/domains/library/router.py"
      - "backend/domains/library/exceptions.py"
      - "backend/domains/library/conftest.py"

    # 从老架构的演变
    legacy_source: |
      - 老架构中 Bookshelves 表是复数形式，代表多个书橱
      - v3 中统一为 Library（单数），每个用户 1 个
      - 提升一层以便支持分享/权限/导出等 Library 级操作

    # 架构实现分层（ADR-008: Library Service & Repository Design）
    implementation_layers:
      domain_layer:
        file: "backend/api/app/modules/domains/library/domain.py"
        responsibility: |
          - Library 聚合根定义（library_id, user_id, name, created_at, updated_at）
          - LibraryName 值对象（name 验证）
          - Factory method: Library.create(user_id, name)
          - Core operations: library.rename(new_name), library.mark_deleted()
          - Domain Events: LibraryCreated, LibraryRenamed, LibraryDeleted, BasementCreated
          - 不直接依赖 Repository 或数据库

      service_layer:
        file: "backend/api/app/modules/domains/library/service.py"
        responsibility: |
          Layer 1: Validation
            - 业务规则检查（RULE-001: 一用户一库）
            - 参数验证（user_id, name 非空）
          Layer 2: Domain Logic
            - 调用 Domain Factory: Library.create()
            - 调用 Domain Methods: library.rename(), library.mark_deleted()
            - 获取发出的 DomainEvents
          Layer 3: Persistence
            - 调用 Repository.save()
            - 捕获 Repository 抛出的异常
            - 转译为 Domain Exceptions（IntegrityError → LibraryAlreadyExistsError）
          Layer 4: Event Publishing
            - 收集 library.events 中的所有事件
            - 异步发布到 EventBus（如果存在）
            - 发布失败时记录日志，不中断主流程
        methods:
          - "create_library(user_id, name) → Library"
          - "get_library(library_id) → Library"
          - "get_user_library(user_id) → Library"
          - "rename_library(library_id, new_name) → Library"
          - "delete_library(library_id) → None"

      repository_layer:
        file: "backend/api/app/modules/domains/library/repository.py"
        responsibility: |
          Interface (LibraryRepository):
            - 抽象接口定义，与 Infrastructure 解耦
          Implementation (LibraryRepositoryImpl):
            - ORM Model ↔ Domain Model 转换（_to_domain）
            - 数据库查询执行
            - 约束冲突捕获和转译（IntegrityError → LibraryAlreadyExistsError）
            - 提供业务查询接口（get_by_user_id 支持 RULE-001）
            - RULE-001 违反检测（多库告警）
            - 完整的异常处理和日志记录
        methods:
          - "save(library) → None (创建或更新)"
          - "get_by_id(library_id) → Optional[Library]"
          - "get_by_user_id(user_id) → Optional[Library] (支持 RULE-001)"
          - "delete(library_id) → None"
          - "exists(library_id) → bool"
          - "_to_domain(model) → Library (DRY 原则)"

      infrastructure_layer:
        file: "backend/api/app/modules/domains/library/models.py"
        responsibility: |
          - LibraryModel ORM 定义
          - 数据库表 libraries（包含 UNIQUE(user_id) 约束）
          - 字段映射：id, user_id, name, basement_bookshelf_id, created_at, updated_at, deleted_at

    invariants:
      RULE-001:
        title: "每个用户只拥有一个 Library"
        description: |
          核心业务规则：1 个 User = 1 个 Library（唯一关系）
          这是系统的最基础约束，确保数据模型的一致性
        statement: "User 与 Library 是 1:1 关系，不能创建多个 Library"
        type: "invariant"
        priority: "critical"
        status: "implemented"
        coverage: "✅ 100%"

        enforcement_layers:
          database:
            - "UNIQUE(user_id) 约束在 libraries 表"
            - "防止数据库级别的重复创建"
          domain:
            - "Service.create_library() 调用 Repository.get_by_user_id() 检查"
            - "Domain 规则验证（业务逻辑）"
          repository:
            - "Repository.get_by_user_id() 检测多条记录 → 告警日志（数据腐败检测）"
            - "Repository.save() 捕获 IntegrityError → 转译为 LibraryAlreadyExistsError"

        implementation:
          service_file: "backend/api/app/modules/domains/library/service.py"
          service_method: "create_library(user_id, name)"
          service_logic: |
            # Layer 1: Validation (L1 - 业务规则检查)
            existing = await repository.get_by_user_id(user_id)
            if existing:
              raise LibraryAlreadyExistsError(...)

            # Layer 2: Domain Logic (L2 - 核心逻辑)
            library = Library.create(user_id, name)

            # Layer 3: Persistence (L3 - 持久化)
            await repository.save(library)

          repository_file: "backend/api/app/modules/domains/library/repository.py"
          repository_methods:
            - method: "get_by_user_id(user_id)"
              logic: |
                # 查询所有该用户的 Library
                models = execute(select(...).where(user_id==user_id)).all()

                # 数据完整性检查
                if len(models) > 1:
                  logger.error("RULE-001 violation: multiple libraries!")
                  # 数据腐败告警，返回第一条

                return _to_domain(models[0])

            - method: "save(library)"
              logic: |
                # 持久化到数据库
                model = LibraryModel(user_id=library.user_id, ...)
                session.add(model)

                # 捕获约束冲突
                try:
                  ...
                except IntegrityError as e:
                  if "user_id" in str(e):
                    raise LibraryAlreadyExistsError(...)

        test_cases:
          - "创建第一个 Library 成功"
          - "创建第二个 Library 失败（Service 层业务规则）"
          - "数据库 UNIQUE 约束冲突被正确处理"
          - "多库情况被 Repository 检测和告警"
          - "异常被正确转译为 Domain Exception"

        related_files:
          - "backend/api/app/modules/domains/library/domain.py"
          - "backend/api/app/modules/domains/library/service.py"
          - "backend/api/app/modules/domains/library/repository.py"
          - "backend/api/app/modules/domains/library/models.py"
          - "assets/docs/ADR/ADR-008-library-service-repository-design.md"

        devlog_entry: "D30-RULE-001-Implemented"
        adr_reference: "ADR-008 (Service Layer - Layer 1: Validation)"
        pr_number: null

      RULE-002:
        title: "Library 拥有唯一的用户身份"
        description: "Library 必须关联到一个有效的 User，不能为空"
        statement: "Library.user_id 是必填字段，且不能为 NULL"
        type: "invariant"
        priority: "critical"
        status: "implemented"
        coverage: "✅ 100%"

        enforcement_layers:
          database: "NOT NULL 约束 + FK 约束在 user_id"
          domain: "Library.create() 检查 user_id 非空"
          service: "Service 方法签名强制 user_id 参数"

        implementation:
          service_file: "backend/api/app/modules/domains/library/service.py"
          service_method: "create_library(user_id: UUID, name: str)"
          service_logic: |
            # user_id 是必填参数，传入 UUID 类型
            # 如果为空或无效，Python 类型检查会捕获
            if not user_id:
              raise ValueError("user_id cannot be empty")

          domain_file: "backend/api/app/modules/domains/library/domain.py"
          domain_factory: |
            @staticmethod
            def create(user_id: UUID, name: str) -> "Library":
              # user_id 类型强制
              if not user_id:
                raise ValueError("user_id is required")
              return Library(user_id=user_id, name=name, ...)

        test_cases:
          - "创建 Library 时传入有效 user_id"
          - "创建 Library 时不传 user_id 会失败"
          - "数据库查询返回的 Library 总是有 user_id"

        related_files:
          - "backend/api/app/modules/domains/library/domain.py"
          - "backend/api/app/modules/domains/library/service.py"

        devlog_entry: "D30-Library-UserAssociation"
        adr_reference: "ADR-001 (Independent Aggregate Roots)"
        pr_number: null

      RULE-003:
        title: "Library 包含唯一的名称"
        description: "Library 必须有一个非空的、≤255 字符的名称"
        statement: "Library.name 是非空字符串，长度范围 1-255"
        type: "invariant"
        priority: "high"
        status: "implemented"
        coverage: "✅ 100%"

        enforcement_layers:
          database: "VARCHAR(255) NOT NULL 在 name 列"
          domain: "LibraryName 值对象验证（1-255 字符）"
          service: "Service 检查 name 参数有效性"

        implementation:
          domain_file: "backend/api/app/modules/domains/library/domain.py"
          value_object: |
            @dataclass(frozen=True)
            class LibraryName(ValueObject):
              value: str

              def __post_init__(self):
                if not self.value or not self.value.strip():
                  raise ValueError("Library name cannot be empty")
                if len(self.value) > 255:
                  raise ValueError("Library name must be ≤ 255 characters")

          service_file: "backend/api/app/modules/domains/library/service.py"
          service_validation: |
            # Layer 1: Validation (L1)
            if not name or not name.strip():
              raise ValueError("name cannot be empty")

            # 通过 Library.create() 时，LibraryName 会再次验证

        test_cases:
          - "创建 Library 时传入有效名称"
          - "创建 Library 时不传名称会失败"
          - "创建 Library 时传入空字符串或超长名称会失败"
          - "重命名 Library 时验证新名称"

        related_files:
          - "backend/api/app/modules/domains/library/domain.py"
          - "backend/api/app/modules/domains/library/service.py"

        devlog_entry: "D30-Library-UniqueName"
        adr_reference: "ADR-001 (Value Objects)"
        pr_number: null

    policies:
      POLICY-001:
        title: "Library 分享和权限管理"
        statement: "Library 可以与其他用户分享（只读或可编辑），支持不同的权限级别。"
        type: "policy"
        status: "future"  # 暂不实现

        devlog_entry: "D32-Library-Sharing"

      POLICY-002:
        title: "Library 导出和备份"
        statement: "支持将整个 Library 导出为 JSON 或 Markdown 格式，支持定期备份。"
        type: "policy"
        status: "future"

        devlog_entry: "D32-Library-Export"

    events:
      LibraryCreated:
        description: "Library 被创建（通常由系统在 User 注册时自动创建）"
        fields:
          - library_id: UUID
          - user_id: UUID
          - created_at: datetime

      LibraryUpdated:
        description: "Library 信息被更新"
        fields:
          - library_id: UUID
          - user_id: UUID
          - updated_at: datetime

    children:
      - bookshelf

# ============================================
# Domain 2: Bookshelf（书架 - 子聚合）
# ============================================

  bookshelf:
    name: "Bookshelf（书架）"
    type: "AggregateRoot"
    description: "Library 下的第一级容器，用于组织和分类 Books。每个 Bookshelf 是独立聚合根。"
    parent: "library"
    status: "implemented"

    # 架构实现分层（ADR-009: Bookshelf Service & Repository Design）
    implementation_layers:
      domain_layer:
        file: "backend/api/app/modules/domains/bookshelf/domain.py"
        responsibility: |
          - Bookshelf 聚合根定义（id, library_id, name, description, status, etc.）
          - BookshelfName/BookshelfDescription 值对象（validation）
          - Factory method: Bookshelf.create(library_id, name)
          - Core methods: rename(), set_description(), mark_deleted()
          - Domain Events: BookshelfCreated, BookshelfRenamed, BookshelfDeleted

      service_layer:
        file: "backend/api/app/modules/domains/bookshelf/service.py"
        responsibility: |
          Layer 1: Validation - 业务规则检查（RULE-006 重名检查）
          Layer 2: Domain Logic - 调用 Domain Factory 和 Methods
          Layer 3: Persistence - Repository.save() + 异常转译
          Layer 4: Event Publishing - 发布事件到 EventBus

      repository_layer:
        file: "backend/api/app/modules/domains/bookshelf/repository.py"
        responsibility: |
          - get_by_id(bookshelf_id) - 单体查询
          - get_by_library_id(library_id) - RULE-005 列表查询
          - get_basement_by_library_id(library_id) - RULE-010 检索
          - exists_by_name(library_id, name) - RULE-006 重名检查
          - save() with IntegrityError handling - 约束冲突转译
          - Exception handling + Logging

    invariants:
      RULE-004:
        title: "Bookshelf 可无限创建"
        statement: "用户可在 Library 下无限创建 Bookshelf，无数量限制。"
        type: "invariant"
        priority: "critical"
        status: "implemented"
        coverage: "✅ 100%"

        enforcement_layers:
          domain: "Bookshelf.create() factory method（无限制）"
          service: "Service.create_bookshelf() L1 验证（RULE-006 重名检查）"
          repository: "Repository.exists_by_name() 检测重复"

        implementation:
          domain_file: "backend/api/app/modules/domains/bookshelf/domain.py (create method)"
          service_file: "backend/api/app/modules/domains/bookshelf/service.py (create_bookshelf - L1)"
          repository_file: "backend/api/app/modules/domains/bookshelf/repository.py (save, exists_by_name)"

        test_cases:
          - "创建多个 Bookshelf 成功"
          - "相同 Library 下无数量限制"

        devlog_entry: "D31-Bookshelf-Unlimited"
        adr_reference: "ADR-009 (Service Layer - Layer 1: Validation)"

      RULE-005:
        title: "Bookshelf 必须属于一个 Library"
        statement: "每个 Bookshelf 必须持有其所属 Library 的 ID（FK: library_id），不能孤立存在。"
        type: "invariant"
        priority: "critical"
        status: "implemented"
        coverage: "✅ 100%"

        enforcement_layers:
          database: "NOT NULL + FK(library_id) 约束"
          domain: "Bookshelf.create() 必须传入 library_id"
          service: "Service.create_bookshelf() 强制参数"

        implementation:
          domain_file: "backend/api/app/modules/domains/bookshelf/domain.py (__init__)"
          service_file: "backend/api/app/modules/domains/bookshelf/service.py (create_bookshelf signature)"

        test_cases:
          - "创建 Bookshelf 时必须传 library_id"
          - "database FK 约束保护"

        devlog_entry: "D31-Bookshelf-BelongsToLibrary"
        adr_reference: "ADR-001 (Independent Aggregate Roots)"

      RULE-006:
        title: "Bookshelf 名称不能重复"
        statement: "同一 Library 下，Bookshelf 名称必须唯一。创建时必须非空且 ≤255 字符。"
        type: "invariant"
        priority: "high"
        status: "implemented"
        coverage: "✅ 100%"

        enforcement_layers:
          database: "UNIQUE(library_id, name) 约束"
          domain: "BookshelfName ValueObject(__post_init__ 检查非空 + 长度)"
          service: "Service L1 validation（exists_by_name 检查）"
          repository: "save() 捕获 IntegrityError → BookshelfAlreadyExistsError"

        implementation:
          domain_file: "backend/api/app/modules/domains/bookshelf/domain.py (BookshelfName)"
          service_file: "backend/api/app/modules/domains/bookshelf/service.py (create_bookshelf - L1)"
          repository_file: "backend/api/app/modules/domains/bookshelf/repository.py (exists_by_name, save)"

        test_cases:
          - "同名 Bookshelf 创建失败（Service L1 检查）"
          - "同名 Bookshelf 创建失败（Database 约束）"
          - "空名称创建失败（ValueObject 验证）"
          - "超长名称创建失败（ValueObject 验证）"

        devlog_entry: "D31-Bookshelf-NameNotEmpty"
        adr_reference: "ADR-009 (Value Objects + Repository exception handling)"

      RULE-010:
        title: "每个 Library 自动创建一个 Basement Bookshelf"
        statement: "系统创建 Library 时，自动创建一个隐藏的 Basement Bookshelf（回收站）。Basement 不能被删除。"
        type: "invariant"
        priority: "critical"
        status: "implemented"
        coverage: "✅ 100%"

        enforcement_layers:
          domain: "Library.create() 发出 BasementCreated 事件"
          service: "Bookshelf.service 监听事件并创建 Basement"
          repository: "get_basement_by_library_id() 专用查询方法"

        implementation:
          library_domain: "backend/api/app/modules/domains/library/domain.py (BasementCreated event)"
          bookshelf_service: "backend/api/app/modules/domains/bookshelf/service.py (get_basement_bookshelf method)"
          bookshelf_repo: "backend/api/app/modules/domains/bookshelf/repository.py (get_basement_by_library_id)"

        design_note: "Basement 是特殊的 Bookshelf（type=BASEMENT），隐藏且不能被删除或重命名。"

        test_cases:
          - "Library 创建时自动生成 Basement"
          - "Basement 无法被用户删除"
          - "Basement 无法被重命名"
          - "get_basement_bookshelf() 正确检索"

        devlog_entry: "D31-Library-BasementAutoCreate"
        adr_reference: "ADR-009 (Basement Pattern for Soft Delete)"

    policies:
      POLICY-003:
        title: "Bookshelf 删除时的 Book 处理"
        statement: |
          删除 Bookshelf 时，其内的 Books 转移到 Basement（Basement Pattern）。
          实现方式：
          1. Service 查询 Bookshelf 内所有 Books
          2. 对每个 Book，调用 book.move_to_basement()
          3. Repository.save() 所有 moved Books
          4. 最后删除 Bookshelf（状态标记为 DELETED）
        type: "policy"
        status: "implemented"

        implementation:
          service_file: "backend/api/app/modules/domains/bookshelf/service.py (delete_bookshelf)"
          book_service: "backend/api/app/modules/domains/book/service.py (会监听 BookshelfDeleted 事件)"

        devlog_entry: "D31-Bookshelf-DeletePolicy"
        adr_reference: "ADR-009 (POLICY-003: Soft Delete with Basement)"

    events:
      BookshelfCreated:
        description: "新 Bookshelf 被创建"
        fields:
          - bookshelf_id: UUID
          - library_id: UUID
          - name: str

      BookshelfRenamed:
        description: "Bookshelf 名称被更改"
        fields:
          - bookshelf_id: UUID
          - old_name: str
          - new_name: str

      BookshelfDeleted:
        description: "Bookshelf 被删除（Books 转移到 Basement）"
        fields:
          - bookshelf_id: UUID
          - library_id: UUID

    children:
      - book

# ============================================
# Domain 3: Book（书籍 - 独立聚合根）
# ============================================

  book:
    name: "Book（书籍）"
    type: "AggregateRoot"
    description: "独立聚合根，通过 bookshelf_id FK 关联到 Bookshelf。支持跨 Bookshelf 转移和软删除（Basement）。对应老架构中的 OrbitNote。"
    parent: "bookshelf"
    status: "implemented"

    # 架构实现分层（ADR-010: Book Service & Repository Design）
    implementation_layers:
      domain_layer:
        file: "backend/api/app/modules/domains/book/domain.py"
        responsibility: |
          - Book 聚合根定义（id, bookshelf_id, library_id, title, status, etc.）
          - BookTitle/BookSummary 值对象（validation）
          - Factory method: Book.create(bookshelf_id, library_id, title, summary)
          - Core methods: rename(), change_status(), move_to_bookshelf(), move_to_basement(), restore_from_basement()
          - Domain Events: BookCreated, BookRenamed, BookStatusChanged, BookMovedToBookshelf, BookMovedToBasement, BookRestoredFromBasement

      service_layer:
        file: "backend/api/app/modules/domains/book/service.py"
        responsibility: |
          Layer 1: Validation - Verify Bookshelf exists, check library_id consistency
          Layer 2: Domain Logic - Call Domain Factory and Methods
          Layer 3: Persistence - Repository.save() + exception translation
          Layer 4: Event Publishing - Publish events to EventBus

      repository_layer:
        file: "backend/api/app/modules/domains/book/repository.py"
        responsibility: |
          - get_by_id() with soft-delete filtering (RULE-012)
          - get_by_bookshelf_id() list all active Books
          - get_deleted_books() retrieve Basement Books (RULE-013)
          - save() with IntegrityError handling
          - _to_domain() helper with library_id + soft_deleted_at mapping
          - Comprehensive logging at all operations

    invariants:
      RULE-009:
        title: "Book 可无限创建"
        statement: "用户可在 Bookshelf 下无限创建 Book，无数量限制。创建时必须正确初始化 library_id（从父 Bookshelf 获取）。"
        type: "invariant"
        priority: "critical"
        status: "implemented"
        coverage: "✅ 100%"

        enforcement_layers:
          domain: "Book.create() factory method（无限制，接收 library_id）"
          service: "Service.create_book() L1 验证（Bookshelf 存在检查）+ L2 初始化 library_id"
          repository: "Repository.save() 持久化 library_id 冗余 FK"

        implementation:
          domain_file: "backend/api/app/modules/domains/book/domain.py (create method)"
          service_file: "backend/api/app/modules/domains/book/service.py (create_book - L1-L2)"
          repository_file: "backend/api/app/modules/domains/book/repository.py (save)"

        test_cases:
          - "创建多个 Book 成功"
          - "library_id 正确从 Bookshelf 初始化"
          - "相同 Bookshelf 下无数量限制"

        devlog_entry: "D32-Book-Unlimited"
        adr_reference: "ADR-010 (Service Layer - Layer 1: Validation)"

      RULE-011:
        title: "Book 可跨 Bookshelf 转移（带权限检查）"
        statement: |
          Book 可以从一个 Bookshelf 转移到另一个（真实转移，不是复制）。
          转移时 Book ID 不变，必须验证：
          1. 目标 Bookshelf 存在
          2. 目标 Bookshelf 属于同一个 Library（library_id 一致）
          3. 目标 Bookshelf 不是 Basement
        type: "invariant"
        priority: "critical"
        status: "implemented"
        coverage: "✅ 100%"

        enforcement_layers:
          service: "Service.move_to_bookshelf() L1 - 三层权限检查（存在、一致、非Basement）"
          repository: "Repository 保存状态变更"

        implementation:
          service_file: "backend/api/app/modules/domains/book/service.py (move_to_bookshelf - L1-L3)"
          domain_file: "backend/api/app/modules/domains/book/domain.py (move_to_bookshelf)"

        test_cases:
          - "跨 Bookshelf 转移成功"
          - "不同 Library 转移失败"
          - "转移到 Basement 失败"
          - "目标 Bookshelf 不存在失败"

        devlog_entry: "D32-Book-Move"
        adr_reference: "ADR-010 (POLICY-005: Book Move Semantics)"

      RULE-012:
        title: "Book 删除时转移到 Basement（软删除）"
        statement: |
          删除 Book 时，不硬删除，而是调用 move_to_basement()。
          Book 仍存在数据库，但 soft_deleted_at 被设置，bookshelf_id 变为 basement_id。
          Service 层必须正确处理：调用 Domain 方法，然后 save() 不 delete()。
        type: "invariant"
        priority: "critical"
        status: "implemented"
        coverage: "✅ 100%"

        enforcement_layers:
          service: "Service.delete_book() L2 调用 book.move_to_basement() L3 调用 save() 不 delete()"
          repository: "Repository.get_by_id() 自动过滤 soft_deleted_at IS NULL"
          repository: "Repository._to_domain() 映射 soft_deleted_at 字段"

        implementation:
          service_file: "backend/api/app/modules/domains/book/service.py (delete_book - L2/L3)"
          domain_file: "backend/api/app/modules/domains/book/domain.py (move_to_basement)"
          repository_file: "backend/api/app/modules/domains/book/repository.py (get_by_id, _to_domain)"

        test_cases:
          - "删除 Book 转移到 Basement（soft_deleted_at 设置）"
          - "Repository 自动过滤已删除 Book"
          - "未调用 repository.delete()"

        devlog_entry: "D32-Book-SoftDelete"
        adr_reference: "ADR-010 (Basement Pattern for Soft Delete)"

      RULE-013:
        title: "Book 可从 Basement 恢复"
        statement: |
          Basement 中的 Book 可调用 restore_from_basement(target_bookshelf_id) 恢复。
          恢复时 soft_deleted_at 被清除，bookshelf_id 变为目标 Bookshelf。
          必须验证目标 Bookshelf 属于同一 Library。
        type: "invariant"
        priority: "high"
        status: "implemented"
        coverage: "✅ 100%"

        enforcement_layers:
          service: "Service.restore_from_basement() L1 - 权限检查 L2 - Domain 恢复 L3 - 持久化"
          repository: "Repository.get_deleted_books() 检索 Basement 中的 Book"
          repository: "Repository._to_domain() 映射 soft_deleted_at"

        implementation:
          service_file: "backend/api/app/modules/domains/book/service.py (restore_from_basement)"
          domain_file: "backend/api/app/modules/domains/book/domain.py (restore_from_basement)"
          repository_file: "backend/api/app/modules/domains/book/repository.py (get_deleted_books)"

        test_cases:
          - "从 Basement 恢复 Book 成功"
          - "soft_deleted_at 清除"
          - "bookshelf_id 变更为目标"

        devlog_entry: "D32-Book-Restore"
        adr_reference: "ADR-010 (RULE-013: Book Restoration)"

    policies:
      POLICY-005:
        title: "Book 转移时的权限检查"
        statement: |
          Book 转移到新 Bookshelf 时，Service 层需验证：
          1. 新 Bookshelf 存在
          2. 新 Bookshelf 属于同一个 Library（library_id 一致）
          3. 新 Bookshelf 不是 Basement（用户不能主动转移到 Basement）
        type: "policy"
        status: "implemented"

        implementation:
          service_file: "backend/api/app/modules/domains/book/service.py (move_to_bookshelf - L1)"

        devlog_entry: "D32-Book-MovePolicy"
        adr_reference: "ADR-010"

    events:
      BookCreated:
        description: "新 Book 被创建"
        fields:
          - book_id: UUID
          - bookshelf_id: UUID
          - library_id: UUID
          - title: str

      BookMovedToBookshelf:
        description: "Book 转移到另一个 Bookshelf"
        fields:
          - book_id: UUID
          - old_bookshelf_id: UUID
          - new_bookshelf_id: UUID

      BookMovedToBasement:
        description: "Book 被删除（转移到 Basement）"
        fields:
          - book_id: UUID
          - old_bookshelf_id: UUID
          - basement_bookshelf_id: UUID

      BookRestoredFromBasement:
        description: "Book 从 Basement 恢复"
        fields:
          - book_id: UUID
          - basement_bookshelf_id: UUID
          - restored_to_bookshelf_id: UUID

    children:
      - block
          # Domain 层
          book = Book.create(
              bookshelf_id=bookshelf_id,
              library_id=library_id,  # ← 必须传入（冗余 FK）
              title=title,
              summary=summary
          )

        implementation:
          domain_file: "backend/api/app/modules/domains/book/domain.py (Line: create())"
          service_file: "backend/api/app/modules/domains/book/service.py (Line: create_book())"

        design_note: "Service 层负责从 Bookshelf 获取 library_id 并传给 Domain"

        devlog_entry: "D32-Book-Unlimited"

      RULE-011:
        title: "Book 可跨 Bookshelf 转移（带权限检查）"
        statement: |
          Book 可以从一个 Bookshelf 转移到另一个（真实转移，不是复制）。
          转移时 Book ID 不变，必须验证：
          1. 目标 Bookshelf 存在
          2. 目标 Bookshelf 属于同一个 Library（library_id 一致）
          3. 目标 Bookshelf 不是 Basement
        type: "invariant"
        priority: "critical"
        status: "implemented"

        code_example: |
          # Domain 层：真实转移
          book.move_to_bookshelf(new_bookshelf_id)
          # 发出事件：BookMovedToBookshelf(old_id, new_id, book_id)

          # Service 层：权限检查
          async def move_to_bookshelf(self, book_id, target_id):
              book = await self.get_book(book_id)

              # 验证目标存在且合法
              target_shelf = await self.bookshelf_repo.get_by_id(target_id)
              if not target_shelf:
                  raise BookshelfNotFoundError()
              if target_shelf.library_id != book.library_id:
                  raise PermissionError("Different Library")
              if target_shelf.is_basement:
                  raise ValueError("Cannot move to Basement")

              book.move_to_bookshelf(target_id)
              await self.repository.save(book)

        implementation:
          domain_file: "backend/api/app/modules/domains/book/domain.py (Line: move_to_bookshelf())"
          service_file: "backend/api/app/modules/domains/book/service.py (Line: move_to_bookshelf())"

        design_note: "Move Semantics（真转移）+ 三层权限检查（存在、一致、Basement）"

        devlog_entry: "D32-Book-Move (ADR-006)"

      RULE-012:
        title: "Book 删除时转移到 Basement（软删除）"
        statement: |
          删除 Book 时，不硬删除，而是调用 move_to_basement(basement_id)。
          Book 仍存在数据库，但 soft_deleted_at 被设置，bookshelf_id 变为 basement_id。
          Service 层必须正确处理：调用 Domain 转移方法，然后 save() 不 delete()。
        type: "invariant"
        priority: "critical"
        status: "implemented"

        code_example: |
          # 删除 Book（实际是转移到 Basement）
          book.move_to_basement(basement_id)
          # soft_deleted_at 被设置为当前时间
          # 发出事件：BookMovedToBasement(...)

          # Service 层实现
          async def delete_book(self, book_id, basement_id):
              book = await self.get_book(book_id)
              book.move_to_basement(basement_id)  # ← Domain 方法
              await self.repository.save(book)   # ← 只保存，不删除！
              # ❌ NOT await self.repository.delete(book_id)

        implementation:
          domain_file: "backend/api/app/modules/domains/book/domain.py (Line: move_to_basement())"
          service_file: "backend/api/app/modules/domains/book/service.py (Line: delete_book())"

        design_note: "Basement 模式：软删除 + 回收站，30 天后自动硬删除。Service 层确保不硬删除。"

        devlog_entry: "D32-Book-SoftDelete (ADR-006)"

      RULE-013:
        title: "Book 可从 Basement 恢复"
        statement: |
          Basement 中的 Book 可调用 restore_from_basement(target_bookshelf_id) 恢复。
          恢复时 soft_deleted_at 被清除，bookshelf_id 变为目标 Bookshelf。
          必须验证目标 Bookshelf 属于同一 Library。
        type: "invariant"
        priority: "high"
        status: "implemented"

        code_example: |
          # 从 Basement 恢复
          book.restore_from_basement(restore_to_bookshelf_id)
          # soft_deleted_at 被清除为 None
          # bookshelf_id 变为新地址
          # 发出事件：BookRestoredFromBasement(...)

        implementation:
          domain_file: "backend/api/app/modules/domains/book/domain.py (Line: restore_from_basement())"
          service_file: "backend/api/app/modules/domains/book/service.py (Line: restore_from_basement())"

        devlog_entry: "D32-Book-Restore (ADR-006)"

    policies:
      POLICY-005:
        title: "Book 转移时的权限检查"
        statement: |
          Book 转移到新 Bookshelf 时，Service 层需验证：
          1. 新 Bookshelf 存在
          2. 新 Bookshelf 属于同一个 Library（library_id 一致）
          3. 新 Bookshelf 不是 Basement（用户不能主动转移到 Basement）
        type: "policy"
        status: "implemented"

        implementation:
          service_file: "backend/api/app/modules/domains/book/service.py (Line: move_to_bookshelf())"

        devlog_entry: "D32-Book-MovePolicy (ADR-006)"

      POLICY-007:
        title: "Basement 中 Book 的自动清理"
        statement: "Basement 中存储超过 30 天的 Book，由外部 Job 自动硬删除。"
        type: "policy"
        status: "future"

        implementation:
          service_file: "backend/api/app/modules/domains/book/service.py (Line: purge_basement)"
          trigger: "Celery / APScheduler Job（每天午夜）"

        devlog_entry: "D32-Book-PurgeBasement"

    events:
      BookCreated:
        description: "新 Book 被创建"
        fields:
          - book_id: UUID
          - bookshelf_id: UUID
          - library_id: UUID
          - title: str

      BookMovedToBookshelf:
        description: "Book 转移到另一个 Bookshelf"
        fields:
          - book_id: UUID
          - old_bookshelf_id: UUID
          - new_bookshelf_id: UUID
          - moved_at: datetime

      BookMovedToBasement:
        description: "Book 被删除（转移到 Basement）"
        fields:
          - book_id: UUID
          - old_bookshelf_id: UUID
          - basement_bookshelf_id: UUID
          - deleted_at: datetime

      BookRestoredFromBasement:
        description: "Book 从 Basement 恢复"
        fields:
          - book_id: UUID
          - basement_bookshelf_id: UUID
          - restored_to_bookshelf_id: UUID
          - restored_at: datetime

      BookStatusChanged:
        description: "Book 状态变更（draft → published → archived → deleted）"
        fields:
          - book_id: UUID
          - old_status: BookStatus
          - new_status: BookStatus

    children:
      - block

# ============================================
# Domain 4: Block（块 - 值对象/最小单位）
# ============================================

  block:
    name: "Block（块）"
    type: "AggregateRoot"
    description: "独立聚合根，通过 book_id FK 关联到 Book。最小内容单位，支持多种类型。从老架构的 blocks_json 扁平化出来。"
    parent: "book"
    status: "implemented"

    # 从老架构的演变
    legacy_source: |
      - 老架构中存储在 OrbitNote.blocks_json 中为 JSON 数组
      - v3 将其独立为数据库表和实体
      - 支持的类型：text, code, image, table, checkpoint, translation, media, etc.
      - 新增字段：metadata（用于存储类型特定的数据）
      - 设计为独立聚合根（不嵌套在 Book 内）

    # Phase 8 优化后的实现分布（ADR-011：Fractional Index + HEADING BlockType）
    implementation_layers:
      domain_layer:
        file: "backend/api/app/modules/domains/block/domain.py"
        lines_of_code: 400
        percentage: "42-44%"
        responsibilities:
          - "Factory methods: create_text(), create_heading(), create_code(), create_image(), create_quote(), create_list()"
          - "Core operations: set_content(), set_order_fractional()"
          - "Soft delete: mark_deleted()"
          - "Query methods: is_heading, heading_level, is_code, etc."
          - "Domain events: BlockCreated, BlockContentChanged, BlockReordered, BlockDeleted"
        core_methods:
          - "create_text(book_id, content, order)"
          - "create_heading(book_id, content, level, order)"
          - "create_code(book_id, content, language, order)"
          - "create_image(book_id, image_url, alt_text, order)"
          - "set_content(new_content)"
          - "set_order_fractional(new_order)"
          - "mark_deleted()"

      service_layer:
        file: "backend/api/app/modules/domains/block/service.py"
        lines_of_code: 85
        percentage: "8-9%"
        responsibilities:
          - "Orchestration: create_text_block(), create_heading_block() with Book validation"
          - "Content management: update_block_content() with permission check"
          - "Ordering: reorder_block() with fractional index calculation"
          - "Soft delete: delete_block() with permission check"
          - "Retrieval: get_block(), list_blocks()"
        permission_validations:
          - "Verify Book exists (repository.get_by_id)"
          - "Verify user ownership via Library (user_id → library.user_id match)"
          - "Validate book_id consistency"
        methods:
          - "create_text_block(book_id, content, order, user_id)"
          - "create_heading_block(book_id, content, level, order, user_id)"
          - "create_code_block(book_id, content, language, order, user_id)"
          - "update_block_content(block_id, new_content, user_id)"
          - "reorder_block(block_id, before_order, after_order, user_id)"
          - "delete_block(block_id, user_id)"
          - "get_block(block_id)"
          - "list_blocks(book_id)"

      repository_layer:
        file: "backend/api/app/modules/domains/block/repository.py"
        responsibilities:
          - "get_by_id(block_id) with soft-delete filtering"
          - "get_by_book_id(book_id) ordered by fractional index"
          - "save(block) with type-specific field handling"
          - "Query soft-deleted blocks: get_deleted_blocks()"
          - "Calculate fractional index: calculate_between_order(before, after)"

    invariants:
      RULE-013:
        title: "Block 可无限创建（通过类型化工厂方法）"
        statement: "用户可在 Book 下无限创建 Block，无数量限制。每个 Block 独立操作，通过类型化工厂方法创建。"
        type: "invariant"
        priority: "critical"
        status: "implemented"

        design_note: "独立聚合根模式：Block 不嵌套在 Book 内，编辑时无需锁整个 Book。类型化工厂方法替代通用 create()。"

        implementation:
          domain_file: "backend/api/app/modules/domains/block/domain.py (Line: create_text, create_heading, etc.)"

        devlog_entry: "D33-Block-Unlimited"

      RULE-014:
        title: "Block 必须有 type（通过 BlockType Enum）"
        statement: "每个 Block 必须有 type（TEXT|HEADING|CODE|IMAGE|QUOTE|LIST|TABLE|DIVIDER）。使用 Enum 确保类型安全。"
        type: "invariant"
        priority: "critical"
        status: "implemented"

        code_example: |
          class Block(AggregateRoot):
              id: UUID
              book_id: UUID        # ← FK（不是 Book 对象）
              bookshelf_id: UUID   # ← 冗余 FK（用于 Bookshelf 删除时级联）
              library_id: UUID     # ← 冗余 FK（用于权限检查）
              type: BlockType      # Enum: TEXT, HEADING, CODE, IMAGE, QUOTE, LIST, TABLE, DIVIDER
              content: str         # 主要内容
              order: Decimal       # 分数索引排序位置（DECIMAL(19,10)）
              # 注意：不再有 title_text, title_level 字段（现在由 HEADING 类型替代）

        implementation:
          domain_file: "backend/api/app/modules/domains/block/domain.py (Line: __init__)"

        design_note: "采用 Enum 而非字符串，类型安全。HEADING 类型替代了之前的 title_text/title_level。"

        devlog_entry: "D33-Block-MustHaveType"

      RULE-015-REVISED:
        title: "Block 有序排列（使用分数索引）"
        statement: |
          Block 通过 order 字段（DECIMAL(19,10) 类型）使用分数索引进行排序。
          拖拽排序时通过计算中间值实现 O(1) 操作，无需批量重新计算。

          算法：
          - 获取左邻近的 Block（left_order）和右邻近的 Block（right_order）
          - 新顺序 = (left_order + right_order) / 2
          - 如果缺少邻近块（插在头尾），使用倍数间隔
        type: "invariant"
        priority: "high"
        status: "implemented"

        design_benefits:
          - "O(1) 拖拽操作（相对 O(n) 批量重计算）"
          - "无需维护整数 ID 的连续性"
          - "并发拖拽安全（不产生冲突）"
          - "支持无限 Block 重排"

        implementation:
          domain_file: "backend/api/app/modules/domains/block/domain.py (Line: set_order_fractional())"
          service_file: "backend/api/app/modules/domains/block/service.py (Line: reorder_block())"

        code_example: |
          # 示例：在 Block A 和 B 之间插入新 Block
          A.order = 10.0
          B.order = 20.0

          # 新 Block 的顺序
          new_order = (10.0 + 20.0) / 2 = 15.0

          # 数据库持久化
          new_block.order = Decimal('15.0')  # DECIMAL(19,10)

          # 再次拖拽新块到 A 和旧新块之间
          old_new_order = 15.0
          new_order_2 = (10.0 + 15.0) / 2 = 12.5

          # 最多 10 次拖拽后达到精度上限（小数点 10 位），此时触发重规范化

        precision_handling: |
          如果小数位数达到 10（DECIMAL 精度限制），执行重规范化：
          1. 查询该 Book 的所有 Blocks（按 order 排序）
          2. 重新分配 order 为整数间隔：10, 20, 30, ...
          3. 在后台异步执行，不阻塞前台操作

        devlog_entry: "D33-Block-FractionalIndexing"

      RULE-013-REVISED:
        title: "Block 类型系统（HEADING 作为独立类型）"
        statement: |
          Block 必须指定一个 type（BlockType Enum）。HEADING 变为独立的块类型，
          而非 title_text/title_level 字段。这简化了类型检查和 UI 渲染。

          支持的类型：
          - TEXT: 普通文本块
          - HEADING: 标题块（替代 title_level 的概念，level 在 BlockType 内）
          - CODE: 代码块
          - IMAGE: 图片块
          - QUOTE: 引用块
          - LIST: 列表块
          - TABLE: 表格块
          - DIVIDER: 分隔线块
        type: "invariant"
        priority: "critical"
        status: "implemented"

        design_benefits:
          - "类型清晰，UI 渲染按类型处理"
          - "删除 title_text/title_level 字段（简化数据模型）"
          - "每个类型可有不同的 content 结构（通过 metadata 扩展）"
          - "支持类型特定的验证和操作"

        implementation:
          domain_file: "backend/api/app/modules/domains/block/domain.py (Line: BlockType Enum)"
          service_file: "backend/api/app/modules/domains/block/service.py (create_heading, create_text, create_code methods)"
          models_file: "backend/api/app/modules/domains/block/models.py (BlockType ORM Enum)"

        code_example: |
          # 创建文本块
          text_block = Block.create_text(
              book_id=book_id,
              content="这是文本内容",
              order=10.0
          )

          # 创建标题块（H2 级）
          heading_block = Block.create_heading(
              book_id=book_id,
              content="二级标题",
              level=2,  # 1-3 for H1-H3
              order=15.0
          )

          # 创建代码块
          code_block = Block.create_code(
              book_id=book_id,
              content="def hello():\n    print('hello')",
              language="python",
              order=20.0
          )

          # Domain 方法（而非字段访问）
          if block.type == BlockType.HEADING:
              print(f"Level: {block.heading_level}")  # 从 metadata 或子类属性读取
          elif block.type == BlockType.CODE:
              print(f"Language: {block.code_language}")
          else:
              print(f"Content: {block.content}")

        field_removal:
          - "删除 Block.title_text 字段"
          - "删除 Block.title_level 字段"
          - "删除 Block.set_title() 方法"
          - "删除 Block.remove_title() 方法"

        db_schema_changes:
          - "删除 blocks 表的 title_text 列"
          - "删除 blocks 表的 title_level 列"
          - "修改 blocks 表 order 列类型 INT → DECIMAL(19,10)"
          - "添加/验证 block_type 列（Enum HEADING|TEXT|CODE|IMAGE|QUOTE|LIST|TABLE|DIVIDER）"
          - "可选：添加 metadata JSONB 列存储类型特定的数据"

        devlog_entry: "D33-Block-TypeSystem"

      RULE-016:
        title: "Block 必须属于一个 Book"
        statement: |
          每个 Block 必须持有其所属 Book 的 ID（FK: book_id）。
          同时持有 bookshelf_id 和 library_id 用于级联和权限。
        type: "invariant"
        priority: "critical"
        status: "implemented"

        design_note: "独立聚合根模式：冗余 FK 用于优化查询和级联操作"

        implementation:
          domain_file: "backend/api/app/modules/domains/block/domain.py (Line: __init__)"

        devlog_entry: "D33-Block-BelongsToBook"

    policies:
      POLICY-008:
        title: "Block 删除策略（软删除）"
        statement: "删除 Block 时，不硬删除，而是标记为 soft_deleted。由定期 purge job 清理 30+ 天的 Block 及其媒体。"
        type: "policy"
        status: "implemented"

        implementation:
          service_file: "backend/api/app/modules/domains/block/service.py (Line: delete_block())"
          domain_file: "backend/api/app/modules/domains/block/domain.py (Line: mark_deleted())"

        devlog_entry: "D33-Block-SoftDelete (ADR-007)"

      POLICY-009:
        title: "Bookshelf 删除时的 Block 级联"
        statement: |
          Bookshelf 删除时，需清理其内所有 Books 的所有 Blocks。
          实现方式：
          1. 查询所有 bookshelf_id = X 的 Blocks（冗余 FK）
          2. 仅标记为 soft_deleted（不硬删除）
          3. 由 purge job 在 30+ 天后硬删除及其媒体
          4. 然后删除 Books
        type: "policy"
        status: "implemented"

        implementation:
          service_file: "backend/api/app/modules/domains/bookshelf/service.py"

        devlog_entry: "D33-Bookshelf-BlockCascade (ADR-007)"

    events:
      BlockCreated:
        description: "新 Block 被创建"
        fields:
          - block_id: UUID
          - book_id: UUID
          - block_type: BlockType
          - order: int

      BlockContentChanged:
        description: "Block 内容被修改"
        fields:
          - block_id: UUID
          - occurred_at: datetime

      BlockReordered:
        description: "Block 顺序被改变（拖拽）"
        fields:
          - block_id: UUID
          - old_order: int
          - new_order: int

      BlockTitleSet:
        description: "Block 标题被设置或变更"
        fields:
          - block_id: UUID
          - title_level: Optional[int]
          - title_text: Optional[str]

      BlockDeleted:
        description: "Block 被删除"
        fields:
          - block_id: UUID
          - book_id: UUID

      POLICY-008:
        title: "Block 类型检验"
        statement: "新增 Block 时，必须验证 type 在允许列表内，metadata 符合 type 的约束。"
        type: "policy"
        status: "planned"

        devlog_entry: "D33-Block-TypeValidation"

    events:
      BlockCreated:
        description: "Block 被创建"

      BlockUpdated:
        description: "Block 被更新"

      BlockDeleted:
        description: "Block 被删除"

      BlockMoved:
        description: "Block 的顺序改变"

# ============================================
# Domain 5: Tag（全局标签 - 值对象）
# ============================================

  tag:
    name: "Tag（标签）"
    type: "ValueObject"
    description: "全局标签系统，与 Book 多对多关联。菜单栏绑定，支持过滤和搜索。对应老架构中的 OrbitTag。"
    status: "planned"

    # 从老架构的演变
    legacy_source: |
      - 对应老架构中的 OrbitTag 表
      - 保留 N:N 关系（通过 BookTag 关联表）
      - 新增"菜单栏绑定"的概念（用户可通过菜单栏点击 Tag 来过滤）
      - 保留字段：id, name, color, icon, description, count（使用次数缓存）

    invariants:
      RULE-018:
        title: "Tag 名称全局唯一"
        statement: "每个 Tag 的名称必须唯一（unique constraint in DB）。"
        type: "invariant"
        priority: "critical"
        status: "planned"

        implementation:
          domain_file: "backend/api/app/modules/tag/domain.py"

        devlog_entry: "D34-Tag-UniqueName"

      RULE-019:
        title: "Tag 与 Book 多对多关联"
        statement: "一个 Tag 可关联多个 Books，一个 Book 可有多个 Tags。"
        type: "invariant"
        priority: "critical"
        status: "planned"

        code_example: |
          class Tag(ValueObject):
              id: UUID
              name: str  # unique
              color: str
              icon: str | None
              description: str | None
              books: List[Book] = relationship(secondary="book_tags")

        devlog_entry: "D34-Tag-BookAssociation"

      RULE-020:
        title: "Tag 支持颜色和图标"
        statement: "每个 Tag 可以设置颜色（十六进制）和图标（Lucide 图标名）用于 UI 展示。"
        type: "invariant"
        priority: "medium"
        status: "planned"

        devlog_entry: "D34-Tag-UIProperties"

    policies:
      POLICY-009:
        title: "Tag 删除策略"
        statement: "删除 Tag 时，自动从所有 Books 移除关联。"
        type: "policy"
        status: "planned"

        devlog_entry: "D34-Tag-DeletionCleanup"

      POLICY-010:
        title: "Tag 菜单栏集成"
        statement: "用户可以在菜单栏点击 Tag 来过滤显示的 Books，支持多 Tag 并集过滤。"
        type: "policy"
        status: "planned"

        devlog_entry: "D34-Tag-MenubarIntegration"

    events:
      TagCreated:
        description: "Tag 被创建"

      TagUpdated:
        description: "Tag 被更新"

      TagDeleted:
        description: "Tag 被删除"

# ============================================
# Domain 6: Chronicle（新增 - 时间追踪）
# ============================================

  chronicle:
    name: "Chronicle（编年史 / 工作日记）"
    type: "AggregateRoot"
    description: "会话级别的时间追踪和日志记录。从老架构的 Checkpoint 分离出来，专门处理时间维度的数据。"
    status: "planned"

    # 从老架构的演变
    legacy_source: |
      - 老架构中 Checkpoint 和 Marker 用于记录工作时间
      - v3 将时间追踪功能独立为 Chronicle 模块
      - 概念重新定义：
        - Session = 一个工作会话（可选与某个 Book 关联）
        - TimeSegment = 工作时间分片（类似老 Marker）
      - 新增功能：Session 汇总、效率分析、Tag 关联

    core_entities:
      Session:
        description: "一个独立的工作会话"
        fields:
          - id: UUID
          - user_id: UUID  # 所属用户
          - book_id: UUID | None  # 可选关联到具体的 Book
          - started_at: datetime
          - ended_at: datetime | None  # null = 进行中
          - title: str  # 会话标题（如"Python 学习"）
          - description: str | None
          - tags: List[UUID]  # 关联的 Tag IDs
          - time_segments: List[TimeSegment]
          - total_duration: int  # 秒数（计算属性）

      TimeSegment:
        description: "Session 内的时间分片"
        fields:
          - id: UUID
          - session_id: UUID
          - started_at: datetime
          - ended_at: datetime
          - duration_seconds: int
          - category: str  # work, pause, break, review, etc.
          - title: str | None
          - description: str | None
          - image_urls: List[str]  # 最多 5 张图片（60x60）
          - tags: List[UUID]  # TimeSegment 级别的 Tag

    invariants:
      RULE-021:
        title: "Session 必须有开始时间"
        statement: "创建 Session 时，started_at 必须填写。"
        type: "invariant"
        priority: "critical"
        status: "planned"

        devlog_entry: "D35-Chronicle-SessionStartTime"

      RULE-022:
        title: "TimeSegment 的时间范围有效性"
        statement: "TimeSegment 的 ended_at 必须 >= started_at，duration_seconds 自动计算。"
        type: "invariant"
        priority: "high"
        status: "planned"

        devlog_entry: "D35-Chronicle-TimeSegmentValidity"

      RULE-023:
        title: "Session 可选关联到 Book"
        statement: "Session 的 book_id 可以为 null，表示通用工作会话；也可指向具体的 Book。"
        type: "invariant"
        priority: "medium"
        status: "planned"

        devlog_entry: "D35-Chronicle-SessionBookAssociation"

    policies:
      POLICY-011:
        title: "Session 自动计算总工作时长"
        statement: "total_duration = sum(time_segment.duration_seconds)，自动聚合。"
        type: "policy"
        status: "planned"

        devlog_entry: "D35-Chronicle-AutoCalculation"

      POLICY-012:
        title: "TimeSegment 删除策略"
        statement: "删除 TimeSegment 时，自动清理关联的图片。删除 Session 时级联删除所有 TimeSegments。"
        type: "policy"
        status: "planned"

        devlog_entry: "D35-Chronicle-DeletionCleanup"

    events:
      SessionStarted:
        description: "工作会话开始"

      SessionEnded:
        description: "工作会话结束"

      TimeSegmentAdded:
        description: "添加时间分片"

      SessionReported:
        description: "会话统计报告生成"

# ============================================
# Domain 7: Media（媒体资源管理）
# ============================================

  media:
    name: "Media（媒体资源）"
    type: "ValueObject"
    description: "统一的媒体存储管理，支持图片、视频等多种类型。对应老架构中的 OrbitMediaResource。"
    status: "planned"

    # 从老架构的演变
    legacy_source: |
      - 对应老架构中的 OrbitMediaResource 表
      - 保留核心字段和存储策略
      - 新增支持的实体类型：BOOKSHELF_COVER, BOOK_COVER, BLOCK_IMAGE, CHRONICLE_ATTACHMENT
      - 改进存储路径管理

    invariants:
      RULE-024:
        title: "Media 必须关联到有效的 entity_type"
        statement: "entity_type 必须是预定义的类型之一（BOOKSHELF_COVER|BOOK_COVER|BLOCK_IMAGE|CHRONICLE_ATTACHMENT|...）。"
        type: "invariant"
        priority: "critical"
        status: "planned"

        devlog_entry: "D36-Media-EntityTypeValidation"

      RULE-025:
        title: "Media 必须有有效的 entity_id"
        statement: "entity_id 必须指向实际存在的实体，不能为 null。"
        type: "invariant"
        priority: "critical"
        status: "planned"

        devlog_entry: "D36-Media-EntityIdValidation"

      RULE-026:
        title: "Media 文件路径固定架构"
        statement: "文件存储路径格式：storage/{entity_type}/{entity_id}/。路径不可变。"
        type: "invariant"
        priority: "high"
        status: "planned"

        code_example: |
          # 示例路径
          storage/bookshelf_cover/bookshelf-uuid-123/cover.jpg
          storage/book_cover/book-uuid-456/preview.png
          storage/block_image/block-uuid-789/image-001.jpg
          storage/chronicle_attachment/session-uuid-000/screenshot.jpg

        devlog_entry: "D36-Media-FixedPathArchitecture"

    policies:
      POLICY-013:
        title: "Media 软删除策略"
        statement: "删除 Media 时，标记 deleted_at 而非物理删除，支持恢复。定期清理规则：deleted_at > 30 天时物理删除。"
        type: "policy"
        status: "planned"

        devlog_entry: "D36-Media-SoftDeletion"

      POLICY-014:
        title: "Media 关联实体删除"
        statement: "当关联的实体被删除时（如 Book 删除），自动标记其所有 Media 为软删除。"
        type: "policy"
        status: "planned"

        devlog_entry: "D36-Media-CascadingDeletion"

    events:
      MediaUploaded:
        description: "媒体文件被上传"

      MediaDeleted:
        description: "媒体文件被删除"

# ============================================
# Domain 8: Search（搜索 - 新增）
# ============================================

  search:
    name: "Search（搜索）"
    type: "Service"
    description: "全文搜索和高级过滤功能，支持基于 Books/Blocks 的内容搜索。"
    status: "planned"

    capabilities:
      - "按关键词全文搜索 Books 和 Blocks"
      - "按 Tag 过滤"
      - "按优先级/紧急度过滤"
      - "按创建/修改时间范围搜索"
      - "按 status 过滤"
      - "多条件组合查询"

    devlog_entry: "D37-Search-FulltextSupport"

# ============================================
# Domain 9: Stats（统计 - 新增）
# ============================================

  stats:
    name: "Stats（统计分析）"
    type: "Service"
    description: "统计数据聚合和分析，支持 Dashboard 展示和用户数据分析。"
    status: "planned"

    metrics:
      - "Books 总数、Bookshelves 总数、Blocks 总数"
      - "创建/修改时间趋势"
      - "Tag 使用频率分布"
      - "工作时间统计（来自 Chronicle）"
      - "热门标签排行"
      - "内容规模（字符数、代码行数）"

    devlog_entry: "D37-Stats-MetricsAggregation"

# ============================================
# Domain 10: Theme（主题 - 新增）
# ============================================

  theme:
    name: "Theme（主题系统）"
    type: "Service"
    description: "用户界面主题管理，支持多主题切换。"
    status: "planned"

    capabilities:
      - "预设主题（Light, Dark, Auto）"
      - "自定义主题配置"
      - "主题同步到所有设备"

    devlog_entry: "D37-Theme-UserPreferences"

# ============================================
# 跨域事件（Cross-Domain Events）
# ============================================

cross_domain_events:
  BookshelfDeleted:
    triggered_by: "bookshelf domain"
    listeners:
      - "block domain: cascade delete"
      - "media domain: cleanup references"
      - "search domain: remove index"
      - "stats domain: recalculate"

  BookDeleted:
    triggered_by: "book domain"
    listeners:
      - "block domain: cascade delete"
      - "media domain: cleanup references"
      - "chronicle domain: update session references"

  BlockDeleted:
    triggered_by: "block domain"
    listeners:
      - "media domain: cleanup references"
      - "search domain: remove from index"

  TagDeleted:
    triggered_by: "tag domain"
    listeners:
      - "book domain: remove tag associations"
      - "chronicle domain: remove from sessions"

# ============================================
# 实现计划（按优先级和依赖）
# ============================================

implementation_phases:

  phase_1_foundations:
    description: "基础设施和 Domain 层核心"
    estimated_duration: "2 weeks"
    rules:
      - RULE-001  # Library 单实例
      - RULE-004  # Bookshelf 无限创建
      - RULE-009  # Book 无限创建
      - RULE-013  # Block 无限创建
      - RULE-018  # Tag 唯一名称
      - RULE-024  # Media entity_type 验证

    tasks:
      - "创建各 domain/*.py 文件"
      - "定义 ORM Models"
      - "编写 Repository 接口"
      - "编写 Unit Tests for Domain"

  phase_2_relationships:
    description: "聚合根间的关系和依赖"
    estimated_duration: "1 week"
    rules:
      - RULE-002  # Library user association
      - RULE-005  # Bookshelf belongs to Library
      - RULE-010  # Book belongs to Bookshelf
      - RULE-016  # Block belongs to Book
      - RULE-019  # Tag-Book association

    tasks:
      - "实现 Foreign Key 约束"
      - "实现 Service 层的关系操作"
      - "编写集成测试"

  phase_3_policies:
    description: "业务政策和级联操作"
    estimated_duration: "1.5 weeks"
    policies:
      - POLICY-003  # Bookshelf deletion
      - POLICY-005  # Book deletion
      - POLICY-007  # Block deletion
      - POLICY-009  # Tag deletion
      - POLICY-013  # Media soft deletion

    tasks:
      - "实现级联删除逻辑"
      - "实现孤立处理逻辑"
      - "编写边界测试"

  phase_4_advanced_features:
    description: "高级功能（复制、转移、搜索、统计）"
    estimated_duration: "2 weeks"
    rules:
      - RULE-012  # Book duplication
      - RULE-017  # Block metadata

    tasks:
      - "实现 Book/Note 复制"
      - "实现 Book 转移"
      - "实现全文搜索（集成 PostgreSQL FTS）"
      - "实现统计汇聚"

  phase_5_chronicle:
    description: "时间追踪模块（独立迭代）"
    estimated_duration: "2 weeks"
    rules:
      - RULE-021  # Session start time
      - RULE-022  # TimeSegment validity
      - RULE-023  # Session book association

    tasks:
      - "实现 Session 和 TimeSegment 实体"
      - "实现时间自动计算"
      - "实现与 Wordloom 日记的集成"

# ============================================
# 验证和测试策略
# ============================================

testing_strategy:

  unit_tests:
    path: "backend/api/app/tests/test_*/test_domain.py"
    coverage_target: ">= 90%"
    focus:
      - "Invariants 验证"
      - "Value Objects 比较"
      - "Domain Logic 单元测试"

  integration_tests:
    path: "backend/api/app/tests/test_*/test_integration.py"
    coverage_target: ">= 80%"
    focus:
      - "Repository 实现"
      - "Service 业务逻辑"
      - "Domain Events 触发"
      - "级联操作（删除、转移）"

  api_tests:
    path: "backend/api/app/tests/test_*/test_router.py"
    coverage_target: ">= 75%"
    focus:
      - "API 端点验证"
      - "请求/响应 Schema"
      - "错误处理"
      - "权限校验"

  e2e_tests:
    path: "backend/api/app/tests/e2e/"
    coverage_target: ">= 50%"
    focus:
      - "完整工作流"
      - "Wordloom 日记集成"
      - "蓝绿部署验证"

# ============================================
# DevLog 和 PR 追踪
# ============================================

devlog_entries:
  D30:
    title: "Library Domain 定义"
    entries:
      - "D30-Library-SingleInstance"
      - "D30-Library-Identity"
      - "D30-Library-UserAssociation"

  D31:
    title: "Bookshelf Domain 定义"
    entries:
      - "D31-Bookshelf-Unlimited"
      - "D31-Bookshelf-BelongsToLibrary"
      - "D31-Bookshelf-NameNotEmpty"
      - "D31-Bookshelf-UnlimitedBooks"
      - "D31-Bookshelf-PriorityUrgency"

  D32:
    title: "Book Domain 定义"
    entries:
      - "D32-Book-Unlimited"
      - "D32-Book-BelongsToBookshelf"
      - "D32-Book-OrderedBlocks"
      - "D32-Bookshelf-CascadingDelete"
      - "D32-Bookshelf-MoveBooks"

  D33:
    title: "Block Domain 定义"
    entries:
      - "D33-Block-Unlimited"
      - "D33-Block-MustHaveType"
      - "D33-Block-Ordering"
      - "D33-Block-BelongsToBook"
      - "D33-Block-Metadata"
      - "D33-Book-CascadingDelete"
      - "D33-Book-Transfer"
      - "D33-Book-Duplication"

  D34:
    title: "Tag 和 Media Domain"
    entries:
      - "D34-Tag-UniqueName"
      - "D34-Tag-BookAssociation"
      - "D34-Tag-UIProperties"
      - "D34-Tag-MenubarIntegration"

  D35:
    title: "Chronicle 模块"
    entries:
      - "D35-Chronicle-SessionStartTime"
      - "D35-Chronicle-TimeSegmentValidity"
      - "D35-Chronicle-SessionBookAssociation"

  D36:
    title: "Media 资源管理"
    entries:
      - "D36-Media-EntityTypeValidation"
      - "D36-Media-EntityIdValidation"
      - "D36-Media-FixedPathArchitecture"

  D37:
    title: "Search 和 Stats 模块"
    entries:
      - "D37-Search-FulltextSupport"
      - "D37-Stats-MetricsAggregation"
      - "D37-Theme-UserPreferences"

# ============================================
# 规则变更历史
# ============================================

changelog:
  "2025-11-10":
    author: "Architecture Team"
    changes:
      - "Initial DDD Rules extraction from legacy architecture"
      - "Defined 25 core invariants and 14 business policies"
      - "Mapped 10 domains with clear responsibilities"
      - "Established 5-phase implementation plan"
